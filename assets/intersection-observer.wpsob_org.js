const MOBILE_BREAKPOINT=750;const DEFAULT_DELAY=300;const DEFAULT_DURATION=900;const parseIntSafe=(value,fallback)=>{const parsed=parseInt(value);return isNaN(parsed)?fallback:parsed};const isMobileDevice=()=>window.innerWidth<MOBILE_BREAKPOINT;document.querySelectorAll("[data-intersection-observer]").forEach((intersectElement,i)=>{const intersectionID=intersectElement.dataset.id;const observerElement=document.querySelector(`[data-id="${intersectionID}"]`);if(!observerElement){console.warn(`Observer element not found for ID: ${intersectionID}`);return}
const intersectOnce=observerElement.dataset.intersectOnce!=="false";const observerOptions={rootMargin:"0px 0px -50% 0px",threshold:0,...((()=>{try{return JSON.parse(observerElement.dataset.intersectionObserver||"{}")}catch{return{}}})())};const animationBody=observerElement.querySelector(".full-width-banner__animation--body");const animationElements=observerElement.querySelectorAll(".full-width-banner__animation");const intersectionObserver=new IntersectionObserver(entries=>{entries.forEach(entry=>{if(!entry.isIntersecting||intersectionID!==entry.target.dataset.id){return}
const isMobile=isMobileDevice();const allowMobileAnimation=observerElement.dataset.animationMobile!=="false";if(isMobile&&!allowMobileAnimation){return}
if(observerElement.classList.contains("isAnimated")&&intersectOnce){return}
observerElement.classList.remove("inAnimation","isAnimated");const animationDelay=animationBody?parseIntSafe(animationBody.dataset.animationDelay,DEFAULT_DELAY):DEFAULT_DELAY;const animationDuration=animationBody?parseIntSafe(animationBody.dataset.animationDuration,DEFAULT_DURATION):DEFAULT_DURATION;setAnimation({observerElement,animationBody,animationElements});const cleanupDelay=(animationElements.length*animationDelay)+(animationDelay+animationDuration);setTimeout(()=>{if(observerElement.classList.contains("isAnimated")&&intersectOnce){intersectionObserver.unobserve(observerElement)}else if(observerElement.classList.contains("isAnimated")&&!intersectOnce){observerElement.classList.remove("isAnimated")}},cleanupDelay)})},observerOptions);intersectionObserver.observe(observerElement);function setAnimation(params){const{observerElement,animationBody,animationElements}=params;if(!animationElements?.length){observerElement.classList.add("isAnimated");return}
const baseAnimationDelay=animationBody?parseIntSafe(animationBody.dataset.animationDelay,DEFAULT_DELAY):DEFAULT_DELAY;const baseAnimationDuration=animationBody?parseIntSafe(animationBody.dataset.animationDuration,DEFAULT_DURATION):DEFAULT_DURATION;observerElement.classList.add("inAnimation");let completedAnimations=0;const totalAnimations=animationElements.length;const scheduleAnimation=(element,index)=>{const elementDelay=parseIntSafe(element.dataset.animationDelay,baseAnimationDelay);const elementDuration=parseIntSafe(element.dataset.animationDuration,baseAnimationDuration);const startDelay=(index+1)*elementDelay;const endDelay=startDelay+elementDuration;setTimeout(()=>{requestAnimationFrame(()=>{element.classList.add("inAnimation");const childElement=element.querySelector("*");if(childElement){childElement.style.animationDuration=`${elementDuration}ms`}})},startDelay);setTimeout(()=>{requestAnimationFrame(()=>{const childElement=element.querySelector("*");if(childElement){childElement.style.animationDuration="";if(!childElement.style.length){childElement.removeAttribute("style")}}
element.classList.remove("inAnimation");element.classList.add("isAnimated");completedAnimations++;if(completedAnimations===totalAnimations){observerElement.classList.remove("inAnimation");observerElement.classList.add("isAnimated")}})},endDelay)};animationElements.forEach((element,i)=>{if(element){scheduleAnimation(element,i)}})}})